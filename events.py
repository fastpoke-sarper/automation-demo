import sqlite3
from datetime import datetime
from sqlite3.dbapi2 import Connection
import hashlib


from constants import ZOOM, MEET


ZOOM = 'zoom'
MEET = 'meet'


class Event():
    """
    A class to represent an event. Google Calendar assings an id to every event, 
    but every instance of an Event will have an id that will be generated by hashing the Google Calendar id, event time, event name, and event url
    So that, if any of those changes, a new event is created in the database
    """
    id = ''
    name = ''
    opened = False
    start_time = None
    url = ''
    service = None
    
    
    def generate_id(self, event_id: str, start_time: datetime, url: str, name: str) -> str:
        """
        Method to generate an id for an Event instance. Id generated by hashing the Google Calendar id, event time, event name, and event url
        """
        return hashlib.md5((event_id + start_time.isoformat(sep=' ') + url + name).encode('utf-8')).hexdigest()
    
    def __init__(self, id: str=None, event_id: str=None, name: str=None, start_time: datetime=None, url: str=None, service: str=None, opened: bool=False):
        
        self.id = id
                
        self.start_time = start_time
        self.url = url
        self.name = name
        if not id: self.id = self.generate_id(event_id, self.start_time, url, name)
        assert service in [ZOOM, MEET]
        self.service = service
        self.opened = opened
        
        
    
    def __str__(self) -> str:
        """
        For debug purposes
        """
        return str((self.id, self.name, self.opened, self.start_time.isoformat(sep=' '), self.url, self.service))
    
    
    
    

class Database():
    '''
    Class for database. A functional class
    '''

    DATABASE_PATH = None
    
    def __init__(self, database_path: str) -> None:
        """
        Initialization needs to be done to set database directory (coming from config file)
        """
        self.DATABASE_PATH = database_path


    def initiate_database(self) -> None:
        """
        Called only once, when the program starts
        """
        connection = sqlite3.connect(self.DATABASE_PATH)

        cursor = connection.cursor()

        cursor.execute('''CREATE TABLE IF NOT EXISTS events
                    (
                    id TEXT PRIMARY KEY, 
                    name TEXT, 
                    opened BOOLEAN NOT NULL DEFAULT 0,
                    start_time DATETIME NOT NULL, 
                    url TEXT NOT NULL,
                    service TEXT NOT NULL
                    )''')
        
        cursor.execute('''
                       CREATE UNIQUE INDEX IF NOT EXISTS unique_hashed_id on events (id)
                       ''')

        connection.commit()
        
        connection.close()


    def get_database_connection(self) -> Connection:
        return sqlite3.connect(self.DATABASE_PATH)

    def commit_and_close(self, connection: Connection) -> None:
        connection.commit()
        connection.close()
    
    def delete_non_opened_events(self) -> None:
        """
        Everytime new events are fetched, events that have not been opened yet are removed from the database.
        This is done to easily sync events from Google Calendar. Instead of identifying events that were deleted and then try to identify them in the database,
        it's easier to just delete all non-opened events, and then adding new ones, which may have been updated
        
        Keep the opened events to prevent duplicate opening of the same event
        """
        conn = self.get_database_connection()
        cursor = conn.cursor()
        
        cursor.execute('DELETE FROM events WHERE opened=0')
        
        self.commit_and_close(conn) 
        
        
    def add_events(self, events: list) -> None:
        """
        Add events to database
        """
        conn = self.get_database_connection()
        cursor = conn.cursor()
                
        
        event_list = [(event.id, event.name, False, event.start_time, event.url, event.service) for event in events]
        
        cursor.executemany('INSERT OR IGNORE INTO events VALUES (?,?,?,?,?,?)', event_list)
        
        
        self.commit_and_close(conn)

    
        
    
    def get_events(self, min_time: datetime, max_time: datetime) -> list:
        """
        Identify and get events to open. Identification done by date range
        """
        
        events = []
        
        conn = self.get_database_connection()
        cursor = conn.cursor()
        
        
        for event in cursor.execute('SELECT * from events WHERE start_time < ? AND start_time > ?', (max_time, min_time)):
            events.append(Event(id=event[0], name=event[1], start_time=datetime.fromisoformat(event[3]), url=event[4], service=event[5], opened=bool(event[2])))
        
        self.commit_and_close(conn)
        
        return events


    def set_event_as_opened(self, event: Event) -> None:
        """
        Set the opened field of an event as "true", so that duplicate openings are prevented
        """
        
        conn = self.get_database_connection()
        
        cursor = conn.cursor()
        
        cursor.execute('UPDATE events SET opened=1 WHERE id = (?)', (event.id,))
        
        self.commit_and_close(conn)

